<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>KnackiMafia</title>
  <!-- Police d'inspiration horror -->
  <link href="https://fonts.googleapis.com/css2?family=Nosifer&display=swap" rel="stylesheet">
  <!-- Police pour les boutons (facultatif) -->
  <link href="https://fonts.googleapis.com/css2?family=Creepster&display=swap" rel="stylesheet">
  <style>
    /* Styles de base */
    html, body {
      margin: 0;
      padding: 0;
      background: #000;
      color: #eee;
      overflow: hidden;
      font-family: 'Nosifer', cursive;
    }
    canvas {
      display: block;
      image-rendering: pixelated;
    }
    /* Crosshair style */
    #crosshair {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 30px;
      height: 30px;
      margin: -15px;
      pointer-events: none;
      filter: drop-shadow(0 0 5px red);
    }
    #crosshair:before, #crosshair:after {
      content: "";
      position: absolute;
      background: red;
      border-radius: 2px;
    }
    #crosshair:before {
      left: 14px;
      top: 0;
      width: 2px;
      height: 30px;
    }
    #crosshair:after {
      top: 14px;
      left: 0;
      width: 30px;
      height: 2px;
    }
    /* HUD & affichages */
    #hudTop {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 100;
      display: flex;
      align-items: center;
      gap: 40px;
    }
    #healthDisplay, #killDisplay, #knackiDisplay, #ammoDisplay {
      font-size: 20px;
      display: flex;
      align-items: center;
      text-shadow: 0 0 5px black;
    }
    #healthDisplay span, 
    #killDisplay span, 
    #knackiDisplay span, 
    #ammoDisplay span {
      display: inline-block;
    }
    #ammoDisplay {
      position: absolute;
      bottom: 10px;
      left: 10px;
    }
    .icon {
      width: 28px;
      height: 28px;
      margin-right: 5px;
      filter: contrast(1.5) brightness(0.8);
    }
    #reloadMessage {
      position: absolute;
      bottom: 50px;
      left: 50%;
      transform: translateX(-15px);
      color: #ffae00;
      font-size: 24px;
      z-index: 100;
      display: none;
      text-shadow: 0 0 5px black;
    }
    /* Texte d'invite pour ramasser une knacki */
    #pickupPrompt {
      position: absolute;
      bottom: 20%;
      left: 50%;
      transform: translateX(-50%);
      font-size: 24px;
      color: #fff;
      z-index: 110;
      display: none;
      text-shadow: 0 0 5px black;
    }
    /* Mini-carte */
    #minimap {
      position: absolute;
      top: 10px;
      right: 10px;
      width: 200px;
      height: 200px;
      background: rgba(0,0,0,0.7);
      border: 2px solid #ff0000;
      border-radius: 50%;
      z-index: 100;
    }
    /* Canvas HUD pour le timer */
    #hud {
      position: absolute;
      bottom: 10px;
      right: 10px;
      width: 250px;
      height: 60px;
      z-index: 150;
      pointer-events: none;
    }
    /* Styles pour les menus */
    .menu-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.95);
      color: #ff0000;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 300;
      text-align: center;
      backdrop-filter: blur(3px);
      padding: 20px;
      box-sizing: border-box;
    }
    .menu-overlay h1 {
      font-size: 56px;
      margin-bottom: 20px;
      text-shadow: 0 0 10px black;
    }
    .menu-overlay p {
      font-size: 22px;
      margin-bottom: 30px;
      max-width: 600px;
      line-height: 1.4;
      text-shadow: 0 0 5px black;
    }
    /* Boutons améliorés */
    .menu-overlay button {
      font-size: 24px;
      margin: 10px;
      padding: 12px 24px;
      background: linear-gradient(145deg, #1a1a1a, #000);
      color: #ff0000;
      border: 2px solid #ff0000;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s ease;
      font-family: 'Creepster', cursive;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.5);
    }
    .menu-overlay button:hover {
      background: linear-gradient(145deg, #ff1a1a, #ff0000);
      color: #fff;
      transform: translateY(-2px);
      box-shadow: 0 8px 12px rgba(0, 0, 0, 0.7);
    }
    .menu-overlay button:active {
      transform: translateY(0);
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.5);
    }
    /* Styles pour le sélecteur de difficulté */
    #difficultyContainer {
      margin-bottom: 20px;
      text-align: center;
    }
    #difficultyLabel {
      font-size: 24px;
      margin-bottom: 10px;
      color: #ff0000;
    }
    #difficultySlider {
      width: 300px;
    }
    /* Fixer la taille des images de mort */
    #deathMenu img {
      width: 300px;
      height: auto;
      margin-bottom: 20px;
    }

    /* Media queries pour petits écrans */
    @media (max-width: 600px) {
      .menu-overlay h1 {
        font-size: 36px;
      }
      .menu-overlay p {
        font-size: 18px;
        max-width: 90%;
        padding: 0 10px;
      }
      .menu-overlay button {
        font-size: 18px;
        margin: 5px;
        padding: 10px 20px;
      }
      .menu-overlay img {
        width: 150px;
        max-width: 80%;
        margin-bottom: 15px;
      }
      #difficultySlider {
        width: 80%;
      }
    }
  </style>
  <script>
    // Détection d'un appareil mobile.
    if (/Mobi|Android/i.test(navigator.userAgent)) {
      document.addEventListener("DOMContentLoaded", function() {
        document.body.innerHTML = 
          `<div id="mobileNotice" style="position:fixed;top:0;left:0;width:100%;height:100%;background:#000;display:flex;flex-direction:column;align-items:center;justify-content:center;color:#fff;padding:20px;box-sizing:border-box;text-align:center;">
            <h1 style="font-family: 'Nosifer', cursive; font-size:48px; margin-bottom:20px;">Jeu non compatible mobile</h1>
            <p style="font-size:20px; margin-bottom:30px; max-width:600px;">
              Casse toi de la gros bouffon !! Cette page est faite pour ordinateur ! Reviens sur pc et fait pas chier !
            </p>
            <button id="backToHome" style="font-size:24px; padding:12px 24px; background:#1a1a1a; color:#ff0000; border:2px solid #ff0000; border-radius:8px; cursor:pointer; font-family: 'Creepster', cursive;">Revenir à l'accueil</button>
          </div>`;
        document.getElementById("backToHome").addEventListener("click", function() {
          window.location.href = "https://hongus.neocities.org/";
        });
      });
    }
  </script>
</head>
<body>
  <!-- Affichage du jeu -->
  <div id="crosshair"></div>
  <div id="hudTop">
    <div id="healthDisplay">
      <img class="icon" src="https://cdn.freebiesupply.com/logos/large/2x/heart-logo-png-transparent.png" alt="Health"/>
      <span>Health: 100</span>
    </div>
    <div id="killDisplay">
      <img class="icon" src="https://pngimg.com/d/skull_PNG112719.png" alt="Kills"/>
      <span>Kills: 0</span>
    </div>
    <div id="knackiDisplay">
      <img class="icon" src="https://i.pinimg.com/736x/c3/5c/3a/c35c3a870fc3510cc1de6ccd332716e5.jpg" alt=""/>
      <span></span>
    </div>
  </div>
  <div id="ammoDisplay">
    <img class="icon" src="https://png.pngtree.com/png-vector/20220610/ourmid/pngtree-gold-bullets-with-steel-tips-realistic-composition-isolated-on-white-background-png-image_4957667.png" alt="Ammo"/>
    <span>Ammo: 10</span>
  </div>
  <div id="reloadMessage">R pour recharger</div>
  <div id="pickupPrompt">E pour ramasser</div>
  <canvas id="minimap" width="200" height="200"></canvas>
  <canvas id="hud" width="250" height="60"></canvas>

  <!-- Menus -->
  <div id="startMenu" class="menu-overlay">
    <img src="https://i.imgur.com/Z9IO5Qf.png" alt="Image du menu" style="width:200px; margin-bottom:20px;">
    <h1>KnackiMafia</h1>
    <p>
      Choisis UNE DIFICULETE ET lance LE JEU !!<br>
      Utilisez ZQSD pour vous déplacer, la souris pour regarder et cliquez pour tirer !! (débile)<br>
      collectez 6 KNACKIS ! pour gagner.
    </p>
    <div id="difficultyContainer">
      <div id="difficultyLabel">Difficulté : Moyen</div>
      <input type="range" id="difficultySlider" min="0" max="100" value="50">
    </div>
    <button id="startButton">Démarrer</button>
    <button id="accueilButtonStart">Accueil</button>
  </div>
  <div id="deathMenu" class="menu-overlay" style="display: none;">
    <img src="https://i.pinimg.com/736x/a8/e9/6a/a8e96a9887710065d97495e078630081.jpg" alt="Vous êtes mort">
    <h1>T'es mort !!! INCAPABLE !!</h1>
    <h2 id="deathStats"></h2>
  </div>
  <div id="victoryMenu" class="menu-overlay" style="display: none;">
    <h1>BRAVO VOUS ALLEZ POUVOIR BIEN MLANEGR AVEC CES KNACKIS</h1>
    <p id="scoreText">Score : </p>
    <button id="restartButtonVictory">Recommencer</button>
    <button id="accueilButtonVictory">Accueil</button>
  </div>

  <!-- Trois.js et scripts du jeu -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    "use strict";
    // -------------------------------------
    // DÉFINITION DES PARAMÈTRES DE DIFFICULTÉ
    // -------------------------------------
    // Valeur par défaut du slider (0: très facile, 100: très difficile)
    let difficultyValue = 50;
    function lerp(a, b, t) {
      return a + (b - a) * t;
    }
    // Ici, on réduit la difficulté générale et on augmente la vie du joueur en mode facile/moyen
    function getDifficultyParams(val) {
      let t = val / 100;
      return {
        enemySpawnFactor: lerp(0.3, 1.2, t),
        enemySpeed: lerp(0.7, 1.8, t),
        bossSpeed: lerp(0.7, 1.8, t),
        playerHealth: Math.round(lerp(250, 80, t))
      };
    }
    let difficultyParams = getDifficultyParams(difficultyValue);

    // -------------------------------------
    // UTILITAIRES DE CHARGEMENT
    // -------------------------------------
    const loadTexture = url => new Promise((resolve, reject) => {
      const img = new Image();
      img.crossOrigin = "anonymous";
      img.onload = () => {
        const tex = new THREE.Texture(img);
        tex.needsUpdate = true;
        resolve(tex);
      };
      img.onerror = () => reject(new Error("Erreur de chargement " + url));
      img.src = url;
    });
    const loadTextures = urls => Promise.all(urls.map(loadTexture));

    // -------------------------------------
    // PARAMÈTRES DU LABYRINTHE
    // -------------------------------------
    const mazeCols = 50, mazeRows = 50, cellSize = 2, wallProb = 0.3, safeThresh = 3;
    const maze = [];
    for (let i = 0; i < mazeRows; i++) {
      maze[i] = [];
      for (let j = 0; j < mazeCols; j++) {
        maze[i][j] = (i === 0 || i === mazeRows - 1 || j === 0 || j === mazeCols - 1)
          ? 1
          : (Math.random() < wallProb ? 1 : 0);
      }
    }
    const countAdj = (i, j) => {
      let count = 0;
      for (let di = -1; di <= 1; di++) {
        for (let dj = -1; dj <= 1; dj++) {
          if (di || dj) {
            if (maze[i + di] && maze[i + di][j + dj] === 1) count++;
          }
        }
      }
      return count;
    };
    const safeCells = [];
    for (let i = 1; i < mazeRows - 1; i++) {
      for (let j = 1; j < mazeCols - 1; j++) {
        if (maze[i][j] === 0 && countAdj(i, j) <= safeThresh) {
          safeCells.push({ i, j });
        }
      }
    }
    const spawnCell = safeCells.length
      ? safeCells[Math.floor(Math.random() * safeCells.length)]
      : { i: Math.floor(mazeRows / 2), j: Math.floor(mazeCols / 2) };

    // -------------------------------------
    // SCÈNE, CAMÉRA, RENDERER
    // -------------------------------------
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);
    const cubeTextureLoader = new THREE.CubeTextureLoader();
    const skyboxImages = [
      'https://i.imgur.com/letiiDk.jpeg',
      'https://i.imgur.com/yLdeQGz.jpeg',
      'https://i.imgur.com/soQHBMK.jpeg',
      'https://i.imgur.com/FmRBMuV.jpeg',
      'https://i.imgur.com/nm0BOjx.jpeg',
      'https://i.imgur.com/8UDDzVg.jpeg'
    ];
    scene.background = cubeTextureLoader.load(skyboxImages);
    
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const offsetX = mazeCols / 2 - 0.5, offsetZ = mazeRows / 2 - 0.5, playerHeight = 1.5;
    camera.position.set((spawnCell.j - offsetX) * cellSize, playerHeight, (spawnCell.i - offsetZ) * cellSize);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(0.3);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);
    
    // -------------------------------------
    // AUDIO & LISTENER
    // -------------------------------------
    const listener = new THREE.AudioListener();
    camera.add(listener);
    document.body.addEventListener("click", () => {
      if (listener.context.state === "suspended") listener.context.resume();
      if (document.pointerLockElement !== document.body && gameState === "playing") {
        document.body.requestPointerLock();
      }
    });
    const shootSound = new THREE.Audio(listener),
          hitSound = new THREE.Audio(listener),
          reloadSound = new THREE.Audio(listener);
    new THREE.AudioLoader().load('https://files.catbox.moe/zej06i.mp3', buffer => { 
      shootSound.setBuffer(buffer); shootSound.setVolume(0.5); 
    });
    new THREE.AudioLoader().load('https://files.catbox.moe/n5qwhu.mp3', buffer => { 
      hitSound.setBuffer(buffer); hitSound.setVolume(0.5); 
    });
    new THREE.AudioLoader().load('https://files.catbox.moe/2ta8rv.mp3', buffer => { 
      reloadSound.setBuffer(buffer); reloadSound.setVolume(0.5); 
    });
    const bossLoopSound = new THREE.PositionalAudio(listener);
    bossLoopSound.setDistanceModel('linear');
    bossLoopSound.setRefDistance(4);
    bossLoopSound.setMaxDistance(20);
    bossLoopSound.setRolloffFactor(1);
    new THREE.AudioLoader().load('https://files.catbox.moe/2xkzik.mp3', buffer => {
      bossLoopSound.setBuffer(buffer);
      bossLoopSound.setLoop(true);
    });
    const bossHitSound = new THREE.Audio(listener);
    new THREE.AudioLoader().load('https://files.catbox.moe/hpoycs.wav', buffer => {
      bossHitSound.setBuffer(buffer);
      bossHitSound.setVolume(1.0);
    });
    
    // -------------------------------------
    // LUMIÈRE
    // -------------------------------------
    const flashlight = new THREE.SpotLight(0xffffff, 3, 40, Math.PI / 8, 0.5);
    flashlight.castShadow = true;
    flashlight.position.copy(camera.position);
    scene.add(flashlight);
    scene.add(flashlight.target);
    
    // -------------------------------------
    // SOL
    // -------------------------------------
    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(mazeCols * cellSize * 2, mazeRows * cellSize * 2),
      new THREE.MeshStandardMaterial({ color: 0x222222 })
    );
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    scene.add(ground);
    loadTexture("https://i.imgur.com/UGB2Ct2.jpeg").then(tex => {
      tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
      tex.repeat.set(mazeCols, mazeRows);
      ground.material.map = tex;
      ground.material.needsUpdate = true;
    });
    
    // -------------------------------------
    // CHARGEMENT DES TEXTURES DE DÉCOR
    // -------------------------------------
    const wallTextureURL = "https://i.imgur.com/JIbGEsB.jpeg";
    const treeTextureURLs = [
      "https://i.imgur.com/B6qerGA.png", 
      "https://i.imgur.com/B6qerGA.png"
    ];
    const interiorBlockTextureURLs = [
      "https://i.imgur.com/S6jWw8a.jpeg",
      "https://i.imgur.com/Y178cQ1.jpeg",
      "https://i.imgur.com/C8QrNid.jpeg",
      "https://i.imgur.com/TPZP442.jpeg",
      "https://i.imgur.com/RGR9tqE.jpeg",
      "https://i.imgur.com/txDE3fC.jpeg",
      "https://i.imgur.com/xgvoLhc.jpeg",
      "https://i.imgur.com/zaJ6hGv.jpeg",
      "https://i.imgur.com/5HFpdzU.jpeg",
      "https://i.imgur.com/kXNEKer.jpeg",
      "https://i.imgur.com/QG1CisR.jpeg",
      "https://i.imgur.com/x0ueBmA.jpeg",
      "https://i.imgur.com/GpTePcU.jpeg",
      "https://i.imgur.com/iGkHIBS.jpeg",
      "https://i.imgur.com/PMEe3vf.jpeg",
      "https://i.imgur.com/sqFr1aA.jpeg",
      "https://i.imgur.com/QzRFeIB.jpeg",
      "https://i.imgur.com/ELBKbju.jpeg",
      "https://i.imgur.com/qR92O8T.jpeg",
      "https://i.imgur.com/U1fQyss.jpeg",
      "https://i.imgur.com/jCWrLuc.jpeg"
    ];
    Promise.all([
      loadTexture(wallTextureURL),
      loadTextures(treeTextureURLs),
      loadTextures(interiorBlockTextureURLs)
    ]).then(textures => {
      const wallTex = textures[0],
            treeTextures = textures[1],
            interiorBlockTextures = textures[2];
      wallTex.wrapS = wallTex.wrapT = THREE.RepeatWrapping;
      const wallMat = new THREE.MeshStandardMaterial({ map: wallTex });
      const treeMats = treeTextures.map(tex => new THREE.MeshStandardMaterial({
        map: tex,
        color: 0x000000,
        transparent: true,
        side: THREE.DoubleSide,
        alphaTest: 0.5
      }));
      const interiorBlockMats = interiorBlockTextures.map(tex => new THREE.MeshStandardMaterial({
        map: tex,
        transparent: true,
        side: THREE.DoubleSide,
        alphaTest: 0.5
      }));
      const wallGeo = new THREE.BoxGeometry(cellSize, 2, cellSize);
      window.walls = [];
      for (let i = 0; i < mazeRows; i++) {
        for (let j = 0; j < mazeCols; j++) {
          if (maze[i][j] === 1) {
            const x = (j - offsetX) * cellSize,
                  z = (i - offsetZ) * cellSize;
            if (i === 0 || i === mazeRows - 1 || j === 0 || j === mazeCols - 1) {
              const m = new THREE.Mesh(wallGeo, wallMat);
              m.position.set(x, 1, z);
              m.castShadow = m.receiveShadow = true;
              scene.add(m);
              walls.push(m);
            } else {
              const centerRow = mazeRows / 2,
                    centerCol = mazeCols / 2,
                    distance = Math.hypot(i - centerRow, j - centerCol);
              let treeProbability = (distance < 10) ? 0.9 : 0.8;
              if (Math.random() < treeProbability) {
                const randomTreeMat = treeMats[Math.floor(Math.random() * treeMats.length)];
                const tree = createRandomTree(x, z, cellSize, randomTreeMat);
                scene.add(tree);
              } else {
                const randomBlockMat = interiorBlockMats[Math.floor(Math.random() * interiorBlockMats.length)];
                const scale = 0.8 + Math.random() * 0.4;
                const blockGeo = new THREE.BoxGeometry(cellSize * scale, 2 * scale, cellSize * scale);
                const block = new THREE.Mesh(blockGeo, randomBlockMat);
                block.position.set(x, (2 * scale) / 2, z);
                block.castShadow = block.receiveShadow = true;
                scene.add(block);
                walls.push(block);
              }
            }
          }
        }
      }
    }).catch(err => console.error(err));
    
    // -------------------------------------
    // FONCTIONS DE CRÉATION D'ARBRES
    // -------------------------------------
    function createRandomTree(x, z, cellSize, treeMat) {
      const variant = Math.floor(Math.random() * 3);
      switch (variant) {
        case 0: return createTreeVariant1(x, z, cellSize, treeMat);
        case 1: return createTreeVariant2(x, z, cellSize, treeMat);
        case 2: return createTreeVariant3(x, z, cellSize, treeMat);
        default: return createTreeVariant1(x, z, cellSize, treeMat);
      }
    }
    function createTreeVariant1(x, z, cellSize, treeMat) {
      const tree = new THREE.Group();
      const treeScaleFactor = 3;
      const width = cellSize * treeScaleFactor, height = 3 * treeScaleFactor;
      const geometry = new THREE.PlaneGeometry(width, height);
      const plane1 = new THREE.Mesh(geometry, treeMat);
      const plane2 = new THREE.Mesh(geometry, treeMat);
      plane1.position.set(0, height / 2, 0);
      plane2.position.set(0, height / 2, 0);
      plane2.rotation.y = Math.PI / 2;
      tree.add(plane1, plane2);
      tree.position.set(x, 0, z);
      return tree;
    }
    function createTreeVariant2(x, z, cellSize, treeMat) {
      const tree = new THREE.Group();
      const treeScaleFactor = 3;
      const width = cellSize * 0.9 * treeScaleFactor, height = 3.5 * treeScaleFactor;
      const geometry = new THREE.PlaneGeometry(width, height);
      for (let i = 0; i < 3; i++) {
        const plane = new THREE.Mesh(geometry, treeMat);
        plane.position.set(0, height / 2, 0);
        plane.rotation.y = (i * Math.PI * 2) / 3;
        tree.add(plane);
      }
      tree.position.set(x, 0, z);
      return tree;
    }
    function createTreeVariant3(x, z, cellSize, treeMat) {
      const tree = new THREE.Group();
      const treeScaleFactor = 3;
      const baseWidth = cellSize * treeScaleFactor, baseHeight = 3 * treeScaleFactor;
      const width1 = baseWidth * (0.8 + Math.random() * 0.4);
      const height1 = baseHeight * (0.9 + Math.random() * 0.3);
      const geometry1 = new THREE.PlaneGeometry(width1, height1);
      const plane1 = new THREE.Mesh(geometry1, treeMat);
      plane1.position.set(0, height1 / 2, 0);
      plane1.rotation.y = Math.random() * Math.PI * 2;
      tree.add(plane1);
      const width2 = baseWidth * (0.8 + Math.random() * 0.4);
      const height2 = baseHeight * (0.9 + Math.random() * 0.3);
      const geometry2 = new THREE.PlaneGeometry(width2, height2);
      const plane2 = new THREE.Mesh(geometry2, treeMat);
      plane2.position.set(0, height2 / 2, 0);
      plane2.rotation.y = plane1.rotation.y + (Math.PI / 2 + (Math.random() - 0.5) * 0.5);
      tree.add(plane2);
      tree.position.set(x, 0, z);
      return tree;
    }
    
    // -------------------------------------
    // CHARGEMENT DE LA TEXTURE POUR LE "KNACKI"
    // -------------------------------------
    let knackiTexture = null;
    const knackiTextureURL = "https://i.imgur.com/GmJDKHQ.jpeg";
    new THREE.TextureLoader().load(knackiTextureURL, texture => {
      knackiTexture = texture;
    });
    
    // -------------------------------------
    // UTILITAIRES SUPPLÉMENTAIRES
    // -------------------------------------
    function getRandomSafeCell(excludeCell) {
      const cells = safeCells.filter(c => !(c.i === excludeCell.i && c.j === excludeCell.j));
      return cells.length ? cells[Math.floor(Math.random() * cells.length)] : { i: Math.floor(mazeRows / 2), j: Math.floor(mazeCols / 2) };
    }
    function getEnemySpawn() {
      const cell = getRandomSafeCell(spawnCell);
      return { x: (cell.j - offsetX) * cellSize, z: (cell.i - offsetZ) * cellSize };
    }
    
    // -------------------------------------
    // ENNEMIS
    // -------------------------------------
    const enemyURLs = [
      "https://i.imgur.com/dV8GRk2.png",
      "https://i.imgur.com/QIwjfsp.jpeg",
      "https://i.imgur.com/lGPOHgu.jpeg",
      "https://i.imgur.com/n9i2uRP.jpeg",
      "https://i.imgur.com/aCX3k2Q.png"
    ];
    let enemyTextures = [], enemies = [];
    loadTextures(enemyURLs).then(textures => {
      enemyTextures = textures;
      for (let i = 0; i < 15; i++) {
        const pos = getEnemySpawn();
        const enemy = new Enemy(pos);
        scene.add(enemy.sprite);
        enemies.push(enemy);
      }
    });
    class Enemy {
      constructor(pos) {
        const randomIndex = Math.floor(Math.random() * enemyTextures.length);
        const mat = new THREE.SpriteMaterial({ map: enemyTextures[randomIndex], transparent: true, alphaTest: 0.5 });
        this.sprite = new THREE.Sprite(mat);
        this.sprite.scale.set(1.5, 1.5, 1.5);
        this.sprite.position.set(pos.x, 1.2, pos.z);
        this.speed = 2 * difficultyParams.enemySpeed;
      }
      update(delta, playerPos) {
        const dir = new THREE.Vector3().subVectors(playerPos, this.sprite.position);
        if (dir.length() > 0.01) {
          dir.normalize();
          this.sprite.position.add(dir.multiplyScalar(this.speed * delta));
        }
      }
    }
    
    // -------------------------------------
    // BOSS (MODE "WANDERING" ET "AGGRESSIVE")
    // -------------------------------------
    let bossTexture = null, bossEnemy = null;
    loadTextures(["https://i.imgur.com/ZWHSjeB.jpeg"]).then(textures => {
      bossTexture = textures[0];
      createBoss();
    });
    class Boss {
      constructor(pos) {
        const mat = new THREE.SpriteMaterial({ map: bossTexture, transparent: true, alphaTest: 0.5 });
        this.sprite = new THREE.Sprite(mat);
        this.sprite.scale.set(3, 3, 3);
        this.sprite.position.set(pos.x, 1.2, pos.z);
        this.speed = 7 * difficultyParams.bossSpeed;
        this.wanderSpeed = this.speed * 0.5;
        this.lastHitTime = 0;
        this.mode = "wandering";
        this.modeTimer = 5;
        this.wanderTarget = null;
        this.slowTimer = 0;
      }
      update(delta, playerPos, elapsedTime) {
        const aggressionFactor = Math.max(0.5, 1 - (elapsedTime / 300));
        if (this.slowTimer > 0) {
          this.slowTimer -= delta;
          if (this.slowTimer < 0) this.slowTimer = 0;
        }
        const slowFactor = this.slowTimer > 0 ? 0.3 : 1.0;
        this.modeTimer -= delta;
        if (this.modeTimer <= 0) {
          if (this.mode === "wandering") {
            this.mode = "aggressive";
            this.modeTimer = 6;
            this.wanderTarget = null;
          } else {
            this.mode = "wandering";
            this.modeTimer = 5;
          }
        }
        const distanceToPlayer = this.sprite.position.distanceTo(playerPos);
        if (this.mode === "wandering" && distanceToPlayer < 4) {
          this.mode = "aggressive";
          this.modeTimer = 6;
          this.wanderTarget = null;
        }
        if (this.mode === "aggressive") {
          const dir = new THREE.Vector3().subVectors(playerPos, this.sprite.position);
          const distance = dir.length();
          if (distance > 0.01) {
            dir.normalize();
            const extraSpeed = distance > 5 ? (distance - 5) * 0.3 : 0;
            const effectiveSpeed = (this.speed + extraSpeed) * slowFactor * aggressionFactor;
            this.sprite.position.add(dir.multiplyScalar(effectiveSpeed * delta));
          }
        } else {
          if (!this.wanderTarget || this.sprite.position.distanceTo(this.wanderTarget) < 0.5) {
            const randomAngle = Math.random() * 2 * Math.PI;
            const randomDistance = 3 + Math.random() * 4;
            this.wanderTarget = new THREE.Vector3(
              this.sprite.position.x + Math.cos(randomAngle) * randomDistance,
              this.sprite.position.y,
              this.sprite.position.z + Math.sin(randomAngle) * randomDistance
            );
          }
          const wanderDir = new THREE.Vector3().subVectors(this.wanderTarget, this.sprite.position);
          if (wanderDir.length() > 0.01) {
            wanderDir.normalize();
            this.sprite.position.add(wanderDir.multiplyScalar(this.wanderSpeed * slowFactor * delta * aggressionFactor));
          }
        }
      }
    }
    function createBoss() {
      const cell = getRandomSafeCell(spawnCell);
      const pos = { x: (cell.j - offsetX) * cellSize, z: (cell.i - offsetZ) * cellSize };
      bossEnemy = new Boss(pos);
      scene.add(bossEnemy.sprite);
      bossEnemy.sprite.add(bossLoopSound);
    }
    
    // -------------------------------------
    // COLLECTE DE KNACKI (remplacé par un sprite)
    // -------------------------------------
    let knackiCount = 0;
    const maxKnacki = 6;
    const knackiCollectibles = [];
    function updateKnackiDisplay() {
      const knackiDisplaySpan = document.getElementById("knackiDisplay").querySelector("span");
      knackiDisplaySpan.innerText = `Knacki: ${knackiCount}/${maxKnacki}`;
    }
    updateKnackiDisplay();
    function spawnKnacki() {
      const cell = safeCells[Math.floor(Math.random() * safeCells.length)];
      const x = (cell.j - offsetX) * cellSize;
      const z = (cell.i - offsetZ) * cellSize;
      if (knackiTexture) {
        const knackiMat = new THREE.SpriteMaterial({ map: knackiTexture, transparent: true, alphaTest: 0.5 });
        const knackiSprite = new THREE.Sprite(knackiMat);
        knackiSprite.scale.set(1.5, 1.5, 1.5);
        knackiSprite.position.set(x, 1, z);
        knackiSprite.castShadow = true;
        scene.add(knackiSprite);
        knackiCollectibles.push(knackiSprite);
      }
    }
    setInterval(() => {
      if (gameState === "playing" && knackiCount < maxKnacki) {
        spawnKnacki();
      }
    }, 25000);
    
    // -------------------------------------
    // VARIABLES DU JOUEUR, DÉPLACEMENT, BALLES, ETC.
    // -------------------------------------
    const baseSpeed = 3, sprintMult = 2;
    const keys = {};
    let yaw = 0, pitch = 0, health = difficultyParams.playerHealth, currentAmmo = 10, isReloading = false, killCount = 0;
    const reloadMessageEl = document.getElementById("reloadMessage");
    const ammoDisplaySpan = document.getElementById("ammoDisplay").querySelector("span");
    const healthDisplaySpan = document.getElementById("healthDisplay").querySelector("span");
    const killDisplaySpan = document.getElementById("killDisplay").querySelector("span");
    
    document.addEventListener("keydown", e => {
      keys[e.code] = true;
      if (e.code === "KeyR") {
        reloadAmmo();
      }
    });
    document.addEventListener("keyup", e => keys[e.code] = false);
    document.addEventListener("mousemove", e => {
      if (document.pointerLockElement === document.body && gameState === "playing") {
        yaw -= e.movementX * 0.002;
        pitch -= e.movementY * 0.002;
        pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch));
      }
    });
    
    const playerMesh = new THREE.Mesh(
      new THREE.SphereGeometry(0.2, 16, 16),
      new THREE.MeshBasicMaterial({ color: 0x00ff00 })
    );
    playerMesh.position.copy(camera.position);
    playerMesh.castShadow = true;
    scene.add(playerMesh);
    
    const updateAmmo = () => {
      ammoDisplaySpan.innerText = `Ammo: ${currentAmmo}`;
      reloadMessageEl.style.display = currentAmmo === 0 ? "block" : "none";
    };
    const updateHealth = () => { healthDisplaySpan.innerText = `Health: ${health}`; };
    const updateKills = () => { killDisplaySpan.innerText = `Kills: ${killCount}`; };
    
    function reloadAmmo() {
      if (!isReloading && currentAmmo < 10) {
        isReloading = true;
        reloadSound.play();
        setTimeout(() => {
          currentAmmo = 10;
          updateAmmo();
          isReloading = false;
        }, 1000);
      }
    }
    
    const bullets = [];
    function shoot() {
      if (gameState !== "playing") return;
      if (isReloading || currentAmmo <= 0) return;
      currentAmmo--;
      updateAmmo();
      const bullet = new THREE.Mesh(
        new THREE.SphereGeometry(0.05, 8, 8),
        new THREE.MeshBasicMaterial({ color: 0xffff00 })
      );
      bullet.position.copy(camera.position);
      const dir = new THREE.Vector3();
      camera.getWorldDirection(dir);
      bullet.userData = { velocity: dir.multiplyScalar(0.5) };
      scene.add(bullet);
      bullets.push(bullet);
      if (shootSound.isPlaying) shootSound.stop();
      shootSound.play();
    }
    document.addEventListener("click", shoot);
    
    const tempBox = new THREE.Box3();
    function sphereVsWall(sphere, wall) {
      tempBox.setFromObject(wall);
      return tempBox.intersectsSphere(sphere);
    }
    
    // -------------------------------------
    // MINI‑CARTE
    // -------------------------------------
    const miniCanvas = document.getElementById("minimap");
    const miniCtx = miniCanvas.getContext("2d");
    const miniScale = miniCanvas.width / (mazeCols * cellSize);
    function drawMinimap() {
      const w = miniCtx.canvas.width, h = miniCtx.canvas.height;
      const cx = w / 2, cy = h / 2;
      miniCtx.clearRect(0, 0, w, h);
      miniCtx.save();
      miniCtx.beginPath();
      miniCtx.arc(cx, cy, cx, 0, Math.PI * 2);
      miniCtx.clip();
      const forward = new THREE.Vector3();
      camera.getWorldDirection(forward);
      miniCtx.translate(cx, cy);
      miniCtx.rotate(-Math.atan2(forward.x, -forward.z));
    
      miniCtx.fillStyle = "#333";
      if (window.walls) {
        window.walls.forEach(wall => {
          const x = wall.position.x - camera.position.x;
          const z = wall.position.z - camera.position.z;
          miniCtx.fillRect(x * miniScale, z * miniScale, cellSize * miniScale, cellSize * miniScale);
        });
      }
      enemies.forEach(e => {
        miniCtx.fillStyle = "#ff0000";
        miniCtx.beginPath();
        miniCtx.arc((e.sprite.position.x - camera.position.x) * miniScale, (e.sprite.position.z - camera.position.z) * miniScale, cellSize * miniScale * 0.3, 0, Math.PI * 2);
        miniCtx.fill();
      });
      if (bossEnemy) {
        miniCtx.fillStyle = "#FFA500";
        miniCtx.beginPath();
        miniCtx.arc((bossEnemy.sprite.position.x - camera.position.x) * miniScale, (bossEnemy.sprite.position.z - camera.position.z) * miniScale, cellSize * miniScale * 0.3, 0, Math.PI * 2);
        miniCtx.fill();
      }
      knackiCollectibles.forEach(knacki => {
        miniCtx.fillStyle = "#ff00ff";
        miniCtx.beginPath();
        miniCtx.arc((knacki.position.x - camera.position.x) * miniScale, (knacki.position.z - camera.position.z) * miniScale, cellSize * miniScale * 0.2, 0, Math.PI * 2);
        miniCtx.fill();
      });
      miniCtx.restore();
      miniCtx.save();
      miniCtx.translate(cx, cy);
      miniCtx.fillStyle = "#00ff00";
      miniCtx.beginPath();
      miniCtx.moveTo(0, -10);
      miniCtx.lineTo(5, 5);
      miniCtx.lineTo(-5, 5);
      miniCtx.closePath();
      miniCtx.fill();
      miniCtx.restore();
      miniCtx.beginPath();
      miniCtx.arc(cx, cy, cx - 1, 0, Math.PI * 2);
      miniCtx.strokeStyle = "white";
      miniCtx.lineWidth = 2;
      miniCtx.stroke();
    }
    
    // -------------------------------------
    // GESTION DES MENUS ET DE L'ÉTAT DU JEU
    // -------------------------------------
    let gameState = "start";
    let startTime = 0;
    function showStartMenu() {
      gameState = "start";
      document.getElementById("startMenu").style.display = "flex";
      document.getElementById("deathMenu").style.display = "none";
      document.getElementById("victoryMenu").style.display = "none";
      if (document.pointerLockElement) {
        document.exitPointerLock();
      }
    }
    function hideMenus() {
      document.getElementById("startMenu").style.display = "none";
      document.getElementById("deathMenu").style.display = "none";
      document.getElementById("victoryMenu").style.display = "none";
    }
    function startGame() {
      hideMenus();
      gameState = "playing";
      startTime = performance.now();
      difficultyParams = getDifficultyParams(difficultyValue);
      health = difficultyParams.playerHealth;
      updateHealth();
      document.body.requestPointerLock();
    }
    function gameOver(cause = "normal") {
      if (gameState !== "playing") return;
      gameState = "dead";
      if (document.pointerLockElement) {
        document.exitPointerLock();
      }
      const deathMenu = document.getElementById("deathMenu");
      const elapsedTimeStr = ((performance.now() - startTime) / 1000).toFixed(1);
      let title = "", imgSrc = "";
      if (cause === "boss") {
        title = "JPEGMAFIA VOUS A ENGLOUTI !! !";
        imgSrc = "https://i.pinimg.com/736x/2c/52/03/2c52032a6070ece8fada09aeaf6206e7.jpg";
      } else {
        title = "Tu t'es fait tué par andy le pédophile !!";
        imgSrc = "https://i.imgur.com/OcqNl52.jpeg";
      }
      deathMenu.innerHTML = 
        `<img src="${imgSrc}" alt="${title}">
        <h1>${title}</h1>
        <h2>Kills: ${killCount} - Temps: ${elapsedTimeStr} sec</h2>
        <button id="restartButtonDeath">Recommencer</button>
        <button id="accueilButtonDeath">Accueil</button>`;
      deathMenu.style.display = "flex";
      document.getElementById("restartButtonDeath").addEventListener("click", () => location.reload());
      document.getElementById("accueilButtonDeath").addEventListener("click", () => window.location.href = "index.html");
    }
    function victory() {
      if (gameState !== "playing") return;
      gameState = "victory";
      if (document.pointerLockElement) {
        document.exitPointerLock();
      }
      const elapsedTime = ((performance.now() - startTime) / 1000).toFixed(1);
      document.getElementById("scoreText").innerText = `Kills: ${killCount} - Temps: ${elapsedTime} sec`;
      document.getElementById("victoryMenu").style.display = "flex";
    }
    document.getElementById("startButton").addEventListener("click", startGame);
    document.getElementById("accueilButtonStart").addEventListener("click", () => window.location.href = "https://hongus.neocities.org/");
    document.getElementById("restartButtonVictory").addEventListener("click", () => location.reload());
    document.getElementById("accueilButtonVictory").addEventListener("click", () => window.location.href = "https://hongus.neocities.org/");
    
    // -------------------------------------
    // GESTION DU SLIDER DE DIFFICULTÉ
    // -------------------------------------
    const difficultySlider = document.getElementById("difficultySlider");
    const difficultyLabel = document.getElementById("difficultyLabel");
    function updateDifficultyLabel(val) {
      difficultyValue = parseInt(val, 10);
      let labelText = "";
      if (difficultyValue < 25) {
        labelText = "Facile";
      } else if (difficultyValue < 50) {
        labelText = "Moyen";
      } else if (difficultyValue < 75) {
        labelText = "Intermédiaire";
      } else {
        labelText = "Difficile";
      }
      difficultyLabel.innerText = "Difficulté : " + labelText;
    }
    difficultySlider.addEventListener("input", e => {
      updateDifficultyLabel(e.target.value);
    });
    updateDifficultyLabel(difficultySlider.value);
    
    // -------------------------------------
    // HUD (Timer et icône)
    // -------------------------------------
    const hudCanvas = document.getElementById("hud");
    const hudCtx = hudCanvas.getContext("2d");
    const clockIcon = new Image();
    clockIcon.src = "https://i.imgur.com/yteToPX.png";
    function drawHUD(elapsedTime) {
      hudCtx.clearRect(0, 0, hudCanvas.width, hudCanvas.height);
      if (clockIcon.complete) {
        hudCtx.drawImage(clockIcon, 5, 10, 40, 40);
      }
      hudCtx.font = "20px Nosifer, cursive";
      hudCtx.fillStyle = "#ff0000";
      hudCtx.fillText("Time: " + elapsedTime.toFixed(1) + " s", 55, 35);
    }
    
    // -------------------------------------
    // COLLECTE MANUELLE DES KNACKI
    // -------------------------------------
    const raycaster = new THREE.Raycaster();
    let currentKnackiTarget = null;
    const pickupPromptEl = document.getElementById("pickupPrompt");
    document.addEventListener("keydown", e => {
      if (e.code === "KeyE" && gameState === "playing" && currentKnackiTarget) {
        scene.remove(currentKnackiTarget);
        const index = knackiCollectibles.indexOf(currentKnackiTarget);
        if (index > -1) {
          knackiCollectibles.splice(index, 1);
        }
        knackiCount++;
        updateKnackiDisplay();
        pickupPromptEl.style.display = "none";
        currentKnackiTarget = null;
        if (knackiCount >= maxKnacki) {
          victory();
        }
      }
    });
    
    // -------------------------------------
    // SPAWN CONTINU DES ENNEMIS
    // -------------------------------------
    let lastEnemySpawnTime = 0;
    
    // -------------------------------------
    // BOUCLE D'ANIMATION
    // -------------------------------------
    const clock = new THREE.Clock();
    function animate() {
      requestAnimationFrame(animate);
      if (gameState === "playing") {
        const delta = clock.getDelta();
        const elapsedTime = (performance.now() - startTime) / 1000;
        camera.rotation.order = "YXZ";
        camera.rotation.set(pitch, yaw, 0);
        flashlight.position.copy(camera.position);
        const d = new THREE.Vector3();
        camera.getWorldDirection(d);
        flashlight.target.position.copy(camera.position).add(d);
        flashlight.target.updateMatrixWorld();
    
        let enemySpawnInterval = Math.max((2 - (elapsedTime / 60)) / difficultyParams.enemySpawnFactor, 0.5);
        if (elapsedTime - lastEnemySpawnTime >= enemySpawnInterval) {
          const pos = getEnemySpawn();
          const enemy = new Enemy(pos);
          scene.add(enemy.sprite);
          enemies.push(enemy);
          lastEnemySpawnTime = elapsedTime;
        }
    
        const move = new THREE.Vector3();
        if (keys["KeyW"]) move.z -= 1;
        if (keys["KeyS"]) move.z += 1;
        if (keys["KeyA"]) move.x -= 1;
        if (keys["KeyD"]) move.x += 1;
        move.normalize().multiplyScalar(baseSpeed * delta * (keys["ShiftLeft"] || keys["ShiftRight"] ? sprintMult : 1));
        move.applyQuaternion(camera.quaternion);
        const newPos = camera.position.clone().add(move);
        newPos.y = playerHeight;
        const sphere = new THREE.Sphere(newPos, 0.2);
        if (window.walls && window.walls.every(w => !sphereVsWall(sphere, w))) {
          camera.position.copy(newPos);
        }
        camera.position.y = playerHeight;
        playerMesh.position.copy(camera.position);
    
        for (let i = bullets.length - 1; i >= 0; i--) {
          const bullet = bullets[i];
          bullet.position.add(bullet.userData.velocity);
          for (let j = enemies.length - 1; j >= 0; j--) {
            if (bullet.position.distanceTo(enemies[j].sprite.position) < 0.5) {
              if (hitSound.isPlaying) hitSound.stop();
              hitSound.play();
              killCount++;
              updateKills();
              scene.remove(enemies[j].sprite);
              enemies.splice(j, 1);
              scene.remove(bullet);
              bullets.splice(i, 1);
              break;
            }
          }
          if (bossEnemy && bullet.position.distanceTo(bossEnemy.sprite.position) < 1.0) {
            bossEnemy.slowTimer += 3;
            scene.remove(bullet);
            bullets.splice(i, 1);
            continue;
          }
          if (bullet.position.distanceTo(camera.position) > 20) {
            scene.remove(bullet);
            bullets.splice(i, 1);
          }
        }
    
        for (let i = enemies.length - 1; i >= 0; i--) {
          enemies[i].update(delta, camera.position);
          if (enemies[i].sprite.position.distanceTo(camera.position) < 0.5) {
            if (hitSound.isPlaying) hitSound.stop();
            hitSound.play();
            scene.remove(enemies[i].sprite);
            enemies.splice(i, 1);
            health -= 25;
            updateHealth();
            if (health <= 0 && gameState === "playing") {
              gameOver("normal");
            }
          }
        }
    
        if (bossEnemy) {
          bossEnemy.update(delta, camera.position, elapsedTime);
          const dist = bossEnemy.sprite.position.distanceTo(camera.position);
          bossLoopSound.setVolume(Math.max(0, 1 - (dist / 20)));
          if (dist < 0.8 && (!bossEnemy.lastHitTime || performance.now() - bossEnemy.lastHitTime > 1000)) {
            bossEnemy.lastHitTime = performance.now();
            if (bossLoopSound.isPlaying) bossLoopSound.stop();
            bossHitSound.play();
            setTimeout(() => {
              health = 0;
              updateHealth();
              gameOver("boss");
            }, 500);
          }
          if (bossLoopSound.buffer && !bossLoopSound.isPlaying && dist >= 0.8) {
            bossLoopSound.play().catch(err => console.error(err));
          }
        }
    
        if (knackiCollectibles.length > 0) {
          raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
          const intersects = raycaster.intersectObjects(knackiCollectibles);
          if (intersects.length > 0 && intersects[0].distance < 3) {
            currentKnackiTarget = intersects[0].object;
            pickupPromptEl.style.display = "block";
          } else {
            currentKnackiTarget = null;
            pickupPromptEl.style.display = "none";
          }
        } else {
          currentKnackiTarget = null;
          pickupPromptEl.style.display = "none";
        }
        drawHUD(elapsedTime);
      }
      drawMinimap();
      renderer.render(scene, camera);
    }
    animate();
    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
